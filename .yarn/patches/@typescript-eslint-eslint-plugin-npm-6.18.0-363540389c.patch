diff --git a/dist/rules/consistent-indexed-object-style.js b/dist/rules/consistent-indexed-object-style.js
index 651bff34af6b6148bb74fd3d4e230745916ad1e7..ede9e103a28d3d18e3190307c75ef23dbe2285b0 100644
--- a/dist/rules/consistent-indexed-object-style.js
+++ b/dist/rules/consistent-indexed-object-style.js
@@ -47,7 +47,7 @@ exports.default = (0, util_1.createRule)({
                 return;
             }
             if (parentId) {
-                const scope = (0, eslint_utils_1.getScope)(context);
+                const scope = (0, eslint_utils_1.getScope)(context, node);
                 const superVar = utils_1.ASTUtils.findVariable(scope, parentId.name);
                 if (superVar) {
                     const isCircular = superVar.references.some(item => item.isTypeReference &&
diff --git a/dist/rules/consistent-type-definitions.js b/dist/rules/consistent-type-definitions.js
index 6d8c3b5300a591ef45a8382a16330b98a64c9607..ef00da0dc4c800e200d7b9a7b0280f116c964b9e 100644
--- a/dist/rules/consistent-type-definitions.js
+++ b/dist/rules/consistent-type-definitions.js
@@ -31,7 +31,7 @@ exports.default = (0, util_1.createRule)({
          * to determine whether any node in tree is globally declared module declaration
          */
         function isCurrentlyTraversedNodeWithinModuleDeclaration() {
-            return (0, eslint_utils_1.getAncestors)(context).some(node => node.type === utils_1.AST_NODE_TYPES.TSModuleDeclaration &&
+            return (0, eslint_utils_1.getAncestors)(context, node).some(node => node.type === utils_1.AST_NODE_TYPES.TSModuleDeclaration &&
                 node.declare &&
                 node.global);
         }
diff --git a/dist/rules/explicit-module-boundary-types.js b/dist/rules/explicit-module-boundary-types.js
index daee4062e46879e43422360cf39865def30a08d9..b2b9e0f755885198ccb2f112567cd6ea80218670 100644
--- a/dist/rules/explicit-module-boundary-types.js
+++ b/dist/rules/explicit-module-boundary-types.js
@@ -228,7 +228,7 @@ exports.default = (0, util_1.createRule)({
             return false;
         }
         function followReference(node) {
-            const scope = (0, eslint_utils_1.getScope)(context);
+            const scope = (0, eslint_utils_1.getScope)(context, node);
             const variable = scope.set.get(node.name);
             /* istanbul ignore if */ if (!variable) {
                 return;
diff --git a/dist/rules/naming-convention.js b/dist/rules/naming-convention.js
index 9cebcecd488fab8212f70693d50edc4927a926a9..00a8b7635fb55440c79bfa4603e1a0cda86e4dbb 100644
--- a/dist/rules/naming-convention.js
+++ b/dist/rules/naming-convention.js
@@ -92,7 +92,7 @@ exports.default = (0, util_1.createRule)({
             return modifiers;
         }
         const unusedVariables = (0, util_1.collectUnusedVariables)(context);
-        function isUnused(name, initialScope = (0, eslint_utils_1.getScope)(context)) {
+        function isUnused(name, initialScope = (0, eslint_utils_1.getScope)(context, node)) {
             let variable = null;
             let scope = initialScope;
             while (scope) {
@@ -167,7 +167,7 @@ exports.default = (0, util_1.createRule)({
                         if (parent.kind === 'const') {
                             baseModifiers.add(naming_convention_utils_1.Modifiers.const);
                         }
-                        if (isGlobal((0, eslint_utils_1.getScope)(context))) {
+                        if (isGlobal((0, eslint_utils_1.getScope)(context, node))) {
                             baseModifiers.add(naming_convention_utils_1.Modifiers.global);
                         }
                     }
@@ -176,7 +176,7 @@ exports.default = (0, util_1.createRule)({
                         if (isDestructured(id)) {
                             modifiers.add(naming_convention_utils_1.Modifiers.destructured);
                         }
-                        if (isExported(parent, id.name, (0, eslint_utils_1.getScope)(context))) {
+                        if (isExported(parent, id.name, (0, eslint_utils_1.getScope)(context, node))) {
                             modifiers.add(naming_convention_utils_1.Modifiers.exported);
                         }
                         if (isUnused(id.name)) {
@@ -199,7 +199,7 @@ exports.default = (0, util_1.createRule)({
                     }
                     const modifiers = new Set();
                     // functions create their own nested scope
-                    const scope = (0, eslint_utils_1.getScope)(context).upper;
+                    const scope = (0, eslint_utils_1.getScope)(context, node).upper;
                     if (isGlobal(scope)) {
                         modifiers.add(naming_convention_utils_1.Modifiers.global);
                     }
@@ -358,7 +358,7 @@ exports.default = (0, util_1.createRule)({
                     }
                     const modifiers = new Set();
                     // classes create their own nested scope
-                    const scope = (0, eslint_utils_1.getScope)(context).upper;
+                    const scope = (0, eslint_utils_1.getScope)(context, node).upper;
                     if (node.abstract) {
                         modifiers.add(naming_convention_utils_1.Modifiers.abstract);
                     }
@@ -377,7 +377,7 @@ exports.default = (0, util_1.createRule)({
                 validator: validators.interface,
                 handler: (node, validator) => {
                     const modifiers = new Set();
-                    const scope = (0, eslint_utils_1.getScope)(context);
+                    const scope = (0, eslint_utils_1.getScope)(context, node);
                     if (isExported(node, node.id.name, scope)) {
                         modifiers.add(naming_convention_utils_1.Modifiers.exported);
                     }
@@ -393,7 +393,7 @@ exports.default = (0, util_1.createRule)({
                 validator: validators.typeAlias,
                 handler: (node, validator) => {
                     const modifiers = new Set();
-                    const scope = (0, eslint_utils_1.getScope)(context);
+                    const scope = (0, eslint_utils_1.getScope)(context, node);
                     if (isExported(node, node.id.name, scope)) {
                         modifiers.add(naming_convention_utils_1.Modifiers.exported);
                     }
@@ -410,7 +410,7 @@ exports.default = (0, util_1.createRule)({
                 handler: (node, validator) => {
                     const modifiers = new Set();
                     // enums create their own nested scope
-                    const scope = (0, eslint_utils_1.getScope)(context).upper;
+                    const scope = (0, eslint_utils_1.getScope)(context, node).upper;
                     if (isExported(node, node.id.name, scope)) {
                         modifiers.add(naming_convention_utils_1.Modifiers.exported);
                     }
@@ -426,7 +426,7 @@ exports.default = (0, util_1.createRule)({
                 validator: validators.typeParameter,
                 handler: (node, validator) => {
                     const modifiers = new Set();
-                    const scope = (0, eslint_utils_1.getScope)(context);
+                    const scope = (0, eslint_utils_1.getScope)(context, node);
                     if (isUnused(node.name.name, scope)) {
                         modifiers.add(naming_convention_utils_1.Modifiers.unused);
                     }
diff --git a/dist/rules/no-empty-interface.js b/dist/rules/no-empty-interface.js
index 131d683fbfc1e2c316c631e3bb6e34aa15edc840..38fd29b60ba188491e0a0b014e4b3ad6f1dc12f1 100644
--- a/dist/rules/no-empty-interface.js
+++ b/dist/rules/no-empty-interface.js
@@ -61,7 +61,7 @@ exports.default = (0, util_1.createRule)({
                             }
                             return fixer.replaceText(node, `type ${sourceCode.getText(node.id)}${typeParam} = ${sourceCode.getText(extend[0])}`);
                         };
-                        const scope = (0, eslint_utils_1.getScope)(context);
+                        const scope = (0, eslint_utils_1.getScope)(context, node);
                         const mergedWithClassDeclaration = scope.set
                             .get(node.id.name)
                             ?.defs.some(def => def.node.type === utils_1.AST_NODE_TYPES.ClassDeclaration);
diff --git a/dist/rules/no-implied-eval.js b/dist/rules/no-implied-eval.js
index 7bab06664e6a394bc2bf6d2e62cfb7659c83544c..af6a26732ab8947d892d70a94c525a599f3b8e3a 100644
--- a/dist/rules/no-implied-eval.js
+++ b/dist/rules/no-implied-eval.js
@@ -114,7 +114,7 @@ exports.default = (0, util_1.createRule)({
             }
         }
         function isReferenceToGlobalFunction(calleeName) {
-            const ref = (0, eslint_utils_1.getScope)(context).references.find(ref => ref.identifier.name === calleeName);
+            const ref = (0, eslint_utils_1.getScope)(context, node).references.find(ref => ref.identifier.name === calleeName);
             // ensure it's the "global" version
             return !ref?.resolved || ref.resolved.defs.length === 0;
         }
diff --git a/dist/rules/no-loop-func.js b/dist/rules/no-loop-func.js
index d033a91177f1eea160199673ce93e92cef5b9296..e814d2402bf8784b46a162b8476fa284c8b86a1b 100644
--- a/dist/rules/no-loop-func.js
+++ b/dist/rules/no-loop-func.js
@@ -32,7 +32,7 @@ exports.default = (0, util_1.createRule)({
             if (!loopNode) {
                 return;
             }
-            const references = (0, eslint_utils_1.getScope)(context).through;
+            const references = (0, eslint_utils_1.getScope)(context, node).through;
             const unsafeRefs = references
                 .filter(r => !isSafe(loopNode, r))
                 .map(r => r.identifier.name);
diff --git a/dist/rules/no-mixed-enums.js b/dist/rules/no-mixed-enums.js
index ae2cacbb225e5c192378a6388c3aaa7c778d54dc..f0f0b0d8cb618983cd4fe1efc12376f215fa3c7d 100644
--- a/dist/rules/no-mixed-enums.js
+++ b/dist/rules/no-mixed-enums.js
@@ -59,7 +59,7 @@ exports.default = (0, util_1.createRule)({
                 imports: [],
                 previousSibling: undefined,
             };
-            let scope = (0, eslint_utils_1.getScope)(context);
+            let scope = (0, eslint_utils_1.getScope)(context, node);
             for (const definition of scope.upper?.set.get(name)?.defs ?? []) {
                 if (definition.node.type === utils_1.AST_NODE_TYPES.TSEnumDeclaration &&
                     definition.node.range[0] < node.range[0] &&
diff --git a/dist/rules/no-non-null-asserted-nullish-coalescing.js b/dist/rules/no-non-null-asserted-nullish-coalescing.js
index acced9584a09c8c5d1af4190898b2faed10f8bae..6302b60c0ea4d128622c0e9e9d70fc7fb676d9bb 100644
--- a/dist/rules/no-non-null-asserted-nullish-coalescing.js
+++ b/dist/rules/no-non-null-asserted-nullish-coalescing.js
@@ -35,7 +35,7 @@ exports.default = (0, util_1.createRule)({
         return {
             'LogicalExpression[operator = "??"] > TSNonNullExpression.left'(node) {
                 if (node.expression.type === utils_1.TSESTree.AST_NODE_TYPES.Identifier) {
-                    const scope = (0, eslint_utils_1.getScope)(context);
+                    const scope = (0, eslint_utils_1.getScope)(context, node);
                     const identifier = node.expression;
                     const variable = utils_1.ASTUtils.findVariable(scope, identifier.name);
                     if (variable && !hasAssignmentBeforeNode(variable, node)) {
diff --git a/dist/rules/no-redeclare.js b/dist/rules/no-redeclare.js
index def016a6c12216a94721085607bef7de3ae585a5..71f3816005a912a158f4ad46b24ce84cb7b0fe93 100644
--- a/dist/rules/no-redeclare.js
+++ b/dist/rules/no-redeclare.js
@@ -166,7 +166,7 @@ exports.default = (0, util_1.createRule)({
          * Find variables in the current scope.
          */
         function checkForBlock(node) {
-            const scope = (0, eslint_utils_1.getScope)(context);
+            const scope = (0, eslint_utils_1.getScope)(context, node);
             /*
              * In ES5, some node type such as `BlockStatement` doesn't have that scope.
              * `scope.block` is a different node in such a case.
@@ -177,7 +177,7 @@ exports.default = (0, util_1.createRule)({
         }
         return {
             Program() {
-                const scope = (0, eslint_utils_1.getScope)(context);
+                const scope = (0, eslint_utils_1.getScope)(context, node);
                 findVariablesInScope(scope);
                 // Node.js or ES modules has a special scope.
                 if (scope.type === scope_manager_1.ScopeType.global &&
diff --git a/dist/rules/no-require-imports.js b/dist/rules/no-require-imports.js
index 2028f91ac9cac61d8a7cf444f50278bd56ce1b10..c9006353cfe082328c91735dfccd6a63f5e47783 100644
--- a/dist/rules/no-require-imports.js
+++ b/dist/rules/no-require-imports.js
@@ -63,7 +63,7 @@ exports.default = util.createRule({
                     isImportPathAllowed(node.arguments[0].value)) {
                     return;
                 }
-                const variable = utils_1.ASTUtils.findVariable((0, eslint_utils_1.getScope)(context), 'require');
+                const variable = utils_1.ASTUtils.findVariable((0, eslint_utils_1.getScope)(context, node), 'require');
                 // ignore non-global require usage as it's something user-land custom instead
                 // of the commonjs standard
                 if (!variable?.identifiers.length) {
diff --git a/dist/rules/no-shadow.js b/dist/rules/no-shadow.js
index 368b5440cb77f1148622d4848d8f94f9dd70d10c..bbc0ad947c085cf48605bd428c757aa9f2a286c2 100644
--- a/dist/rules/no-shadow.js
+++ b/dist/rules/no-shadow.js
@@ -468,7 +468,7 @@ exports.default = (0, util_1.createRule)({
         }
         return {
             'Program:exit'() {
-                const globalScope = (0, eslint_utils_1.getScope)(context);
+                const globalScope = (0, eslint_utils_1.getScope)(context, node);
                 const stack = globalScope.childScopes.slice();
                 while (stack.length) {
                     const scope = stack.pop();
diff --git a/dist/rules/no-unsafe-declaration-merging.js b/dist/rules/no-unsafe-declaration-merging.js
index 7c3d2f5a54d24e1fdaa63e106be657d1171e2e7a..d0678e846a4a1b3892b6fc1845c4b9effdcd5311 100644
--- a/dist/rules/no-unsafe-declaration-merging.js
+++ b/dist/rules/no-unsafe-declaration-merging.js
@@ -40,7 +40,7 @@ exports.default = (0, util_1.createRule)({
                 if (node.id) {
                     // by default eslint returns the inner class scope for the ClassDeclaration node
                     // but we want the outer scope within which merged variables will sit
-                    const currentScope = (0, eslint_utils_1.getScope)(context).upper;
+                    const currentScope = (0, eslint_utils_1.getScope)(context, node).upper;
                     if (currentScope == null) {
                         return;
                     }
@@ -48,7 +48,7 @@ exports.default = (0, util_1.createRule)({
                 }
             },
             TSInterfaceDeclaration(node) {
-                checkUnsafeDeclaration((0, eslint_utils_1.getScope)(context), node.id, utils_1.AST_NODE_TYPES.ClassDeclaration);
+                checkUnsafeDeclaration((0, eslint_utils_1.getScope)(context, node), node.id, utils_1.AST_NODE_TYPES.ClassDeclaration);
             },
         };
     },
diff --git a/dist/rules/no-unused-vars.js b/dist/rules/no-unused-vars.js
index 91b8f2c92cc4d3d10035b469a65a4942addf5b48..01e56facbfefb8dbafd04e38b5f24e70083931e2 100644
--- a/dist/rules/no-unused-vars.js
+++ b/dist/rules/no-unused-vars.js
@@ -214,7 +214,7 @@ exports.default = (0, util_1.createRule)({
             // this is workaround as this change should be done in better way
             'TSModuleDeclaration > TSModuleDeclaration'(node) {
                 if (node.id.type === utils_1.AST_NODE_TYPES.Identifier) {
-                    let scope = (0, eslint_utils_1.getScope)(context);
+                    let scope = (0, eslint_utils_1.getScope)(context, node);
                     if (scope.upper) {
                         scope = scope.upper;
                     }
@@ -382,7 +382,7 @@ exports.default = (0, util_1.createRule)({
                     }
                     break;
             }
-            let scope = (0, eslint_utils_1.getScope)(context);
+            let scope = (0, eslint_utils_1.getScope)(context, node);
             const shouldUseUpperScope = [
                 utils_1.AST_NODE_TYPES.TSModuleDeclaration,
                 utils_1.AST_NODE_TYPES.TSDeclareFunction,
diff --git a/dist/rules/no-use-before-define.js b/dist/rules/no-use-before-define.js
index ce8e7936ebb9cbf11ebf27f22e54708526b5e0c7..e3e50d8cbd7587f58f0e6844d3dbd693b146747f 100644
--- a/dist/rules/no-use-before-define.js
+++ b/dist/rules/no-use-before-define.js
@@ -289,7 +289,7 @@ exports.default = (0, util_1.createRule)({
         }
         return {
             Program() {
-                findVariablesInScope((0, eslint_utils_1.getScope)(context));
+                findVariablesInScope((0, eslint_utils_1.getScope)(context, node));
             },
         };
     },
diff --git a/dist/rules/no-var-requires.js b/dist/rules/no-var-requires.js
index fb1074163ad5bc8cf8c36edb8fecdc7a1f6b88ae..41adc299480cfa8e5976aa63c63b790b170f2045 100644
--- a/dist/rules/no-var-requires.js
+++ b/dist/rules/no-var-requires.js
@@ -52,7 +52,7 @@ exports.default = (0, util_1.createRule)({
                     utils_1.AST_NODE_TYPES.TSTypeAssertion,
                     utils_1.AST_NODE_TYPES.VariableDeclarator,
                 ].includes(parent.type)) {
-                    const variable = utils_1.ASTUtils.findVariable((0, eslint_utils_1.getScope)(context), 'require');
+                    const variable = utils_1.ASTUtils.findVariable((0, eslint_utils_1.getScope)(context, node), 'require');
                     if (!variable?.identifiers.length) {
                         context.report({
                             node,
diff --git a/dist/rules/prefer-includes.js b/dist/rules/prefer-includes.js
index e56192c4ea477b8d176076b38a5f4c3921bcd07a..c424e593abc636348daee29dd365ab7b1c494234 100644
--- a/dist/rules/prefer-includes.js
+++ b/dist/rules/prefer-includes.js
@@ -46,11 +46,10 @@ exports.default = (0, util_1.createRule)({
         schema: [],
     },
     create(context) {
-        const globalScope = (0, eslint_utils_1.getScope)(context);
         const services = (0, util_1.getParserServices)(context);
         const checker = services.program.getTypeChecker();
         function isNumber(node, value) {
-            const evaluated = (0, util_1.getStaticValue)(node, globalScope);
+            const evaluated = (0, util_1.getStaticValue)(node, (0, eslint_utils_1.getScope)(context, node));
             return evaluated != null && evaluated.value === value;
         }
         function isPositiveCheck(node) {
@@ -101,7 +100,7 @@ exports.default = (0, util_1.createRule)({
          * @param node The node to parse.
          */
         function parseRegExp(node) {
-            const evaluated = (0, util_1.getStaticValue)(node, globalScope);
+            const evaluated = (0, util_1.getStaticValue)(node, (0, eslint_utils_1.getScope)(context, node));
             if (evaluated == null || !(evaluated.value instanceof RegExp)) {
                 return null;
             }
diff --git a/dist/rules/prefer-regexp-exec.js b/dist/rules/prefer-regexp-exec.js
index fa0a927172e9e6ca7d8352bf2ad7baf451a53646..22ae2cb40d0f728fab0de149d07b38c7c0d06055 100644
--- a/dist/rules/prefer-regexp-exec.js
+++ b/dist/rules/prefer-regexp-exec.js
@@ -50,7 +50,6 @@ exports.default = (0, util_1.createRule)({
         schema: [],
     },
     create(context) {
-        const globalScope = (0, eslint_utils_1.getScope)(context);
         const services = (0, util_1.getParserServices)(context);
         const checker = services.program.getTypeChecker();
         const sourceCode = (0, eslint_utils_1.getSourceCode)(context);
@@ -95,7 +94,7 @@ exports.default = (0, util_1.createRule)({
                 const objectNode = memberNode.object;
                 const callNode = memberNode.parent;
                 const [argumentNode] = callNode.arguments;
-                const argumentValue = (0, util_1.getStaticValue)(argumentNode, globalScope);
+                const argumentValue = (0, util_1.getStaticValue)(argumentNode, (0, eslint_utils_1.getScope)(context, node));
                 if (!isStringType(services.getTypeAtLocation(objectNode))) {
                     return;
                 }
diff --git a/dist/rules/prefer-string-starts-ends-with.js b/dist/rules/prefer-string-starts-ends-with.js
index 98b823bcb2a3e344911654ce2831e3eaac0846fb..558dd96b89bd4e742da6ac6d544b91e3bd801c60 100644
--- a/dist/rules/prefer-string-starts-ends-with.js
+++ b/dist/rules/prefer-string-starts-ends-with.js
@@ -24,7 +24,6 @@ exports.default = (0, util_1.createRule)({
         fixable: 'code',
     },
     create(context) {
-        const globalScope = (0, eslint_utils_1.getScope)(context);
         const sourceCode = (0, eslint_utils_1.getSourceCode)(context);
         const services = (0, util_1.getParserServices)(context);
         const checker = services.program.getTypeChecker();
@@ -41,7 +40,7 @@ exports.default = (0, util_1.createRule)({
          * @param node The node to check.
          */
         function isNull(node) {
-            const evaluated = (0, util_1.getStaticValue)(node, globalScope);
+            const evaluated = (0, util_1.getStaticValue)(node, (0, eslint_utils_1.getScope)(context, node));
             return evaluated != null && evaluated.value == null;
         }
         /**
@@ -50,7 +49,7 @@ exports.default = (0, util_1.createRule)({
          * @param value The expected value of the `Literal` node.
          */
         function isNumber(node, value) {
-            const evaluated = (0, util_1.getStaticValue)(node, globalScope);
+            const evaluated = (0, util_1.getStaticValue)(node, (0, eslint_utils_1.getScope)(context, node));
             return evaluated != null && evaluated.value === value;
         }
         /**
@@ -59,7 +58,7 @@ exports.default = (0, util_1.createRule)({
          * @param kind The method name to get a character.
          */
         function isCharacter(node) {
-            const evaluated = (0, util_1.getStaticValue)(node, globalScope);
+            const evaluated = (0, util_1.getStaticValue)(node, (0, eslint_utils_1.getScope)(context, node));
             return (evaluated != null &&
                 typeof evaluated.value === 'string' &&
                 // checks if the string is a character long
@@ -106,11 +105,11 @@ exports.default = (0, util_1.createRule)({
          */
         function isLengthExpression(node, expectedObjectNode) {
             if (node.type === utils_1.AST_NODE_TYPES.MemberExpression) {
-                return ((0, util_1.getPropertyName)(node, globalScope) === 'length' &&
+                return ((0, util_1.getPropertyName)(node, (0, eslint_utils_1.getScope)(context, node)) === 'length' &&
                     isSameTokens(node.object, expectedObjectNode));
             }
-            const evaluatedLength = (0, util_1.getStaticValue)(node, globalScope);
-            const evaluatedString = (0, util_1.getStaticValue)(expectedObjectNode, globalScope);
+            const evaluatedLength = (0, util_1.getStaticValue)(node, (0, eslint_utils_1.getScope)(context, node));
+            const evaluatedString = (0, util_1.getStaticValue)(expectedObjectNode, (0, eslint_utils_1.getScope)(context, node));
             return (evaluatedLength != null &&
                 evaluatedString != null &&
                 typeof evaluatedLength.value === 'number' &&
@@ -191,7 +190,7 @@ exports.default = (0, util_1.createRule)({
          * @param node The node to parse.
          */
         function parseRegExp(node) {
-            const evaluated = (0, util_1.getStaticValue)(node, globalScope);
+            const evaluated = (0, util_1.getStaticValue)(node, (0, eslint_utils_1.getScope)(context, node));
             if (evaluated == null || !(evaluated.value instanceof RegExp)) {
                 return null;
             }
